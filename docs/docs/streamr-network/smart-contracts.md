---
sidebar_position: 4
---

# Smart contracts
Streamr can be deployed on any EVM compatible chain. Current deployments are Polygon PoS and the Polygon Amoy testnet.

- The Stream Registry [smart contracts](https://github.com/streamr-dev/network-contracts/tree/master/packages/network-contracts/contracts/StreamRegistry)
- Incentive layer Operator [smart contracts](https://github.com/streamr-dev/network-contracts/tree/master/packages/network-contracts/contracts/OperatorTokenomics)

## Smart contract usage

Please refer to the [network incentives document](./incentives/network-incentives.md) for the high-level description of the tokenomics system. There you also find described two processes: delegation and staking. In delegation, node operators receive DATA tokens from delegators who then receive a share of the profits generated by the operators. In staking, node operators stake the DATA tokens into Sponsorship contracts, and withdraw earnings; sponsoring is included in the staking process as well.

The relevant transactions in the delegation process are:
- Delegation, sending DATA tokens into the Operator contract: [`DATA.transferAndCall(operatorAddress, amountWei, delegatorAddress)`](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L271)
  - `transferAndCall` will then activate the Operator contract to register the delegation
- Undelegation, requesting DATA tokens back, either partially or in full: [`Operator.undelegate(amountWei)`](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L339)
  - the DATA tokens will only return immediate insofar as the Operator contract happens to hold non-staked tokens. The undelegation goes into a queue that gets resolved when DATA returns to the Operator, either via withdrawing or unstaking. The queue takes always precedence: delegators are paid their DATA before they can be re-staked.
  - in case the operator doesn't withdraw earnings and/or unstake enough tokens to pay out the queued delegators, then after 30 days, anyone can force the Operator contract to unstake from a sponsorship contract: [`Operator.forceUnstake(sponsorshipAddress, 0)`](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L441)

The relevant transactions in the staking process are:
- Staking, sending DATA tokens from Operator to Sponsorships: [Operator.stake(sponsorshipAddress, amountWei)](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L404)
  - this same function can be used for adding stake, so calling this 2nd time with same arguments will double the stake (*not* idempotent)
  - once staked, the operator must start also brokering the streams associated with the Sponsorship, or risk getting slashed from the stake
- Withdrawing, pulling DATA token earnings from Sponsorship: [Operator.withdrawEarningsFromSponsorships(sponsorshipAddressList)](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L467)
- Unstaking, pulling DATA token earnings and all stake from Sponsorship: [Operator.unstake(sponsorshipAddress, amountWei)](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L427)
  - once unstaked, the operator may stop brokering the streams associated with the Sponsorship; they receive the stake back, so slashing can't happen anymore
- Reducing stake, pulling some stake back from Sponsorship: [Operator.reduceStakeTo(sponsorshipAddress, targetStakeWei)](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L413)
  - calling this 2nd time with same arguments will fail with `Sponsorship.CannotIncreaseStakeUsingReduceStakeTo` error

- Sponsoring: [`DATA.transferAndCall(operatorAddress, amountWei, 0x0)`](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Sponsorship.sol#L148)
  - `transferAndCall` will then activate the Sponsorship contract to register the sponsoring

### ERC20 compatibility

The tokenomics contracts have been written in such a way that `transferAndCall` isn't strictly required from the token, but any ERC20 token will also work. This however will require an extra `approve` transaction on the token before the actual smart contract call that does the sponsoring or delegating.

When sponsoring, the `transferAndCall` can be replaced with an [`IERC20.approve(operatorAddress, amountWei)`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L52) followed by [`Sponsorship.sponsor`](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Sponsorship.sol#L171).

When delegating, the `transferAndCall` can be replaced with an [`IERC20.approve(operatorAddress, amountWei)`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L52) followed by [`Operator.delegate(amountWei)`](https://github.com/streamr-dev/network-contracts/blob/master/packages/network-contracts/contracts/OperatorTokenomics/Operator.sol#L302).
